<!DOCTYPE html>
<html>
<head>
  <base href="https://websim.ai/cosmic-enigma/">
  <title>CLEARUFO.SPACE IMAGE/VIDEO PROCESSOR - Full Page Layout</title>
  <style>
    /* Existing CSS Styles */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: 'Arial', sans-serif;
    }
    
    .stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    .content {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      min-height: 100vh;
      text-align: center;
      position: relative;
      z-index: 1;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .glowing-window {
      background-color: rgba(25, 25, 35, 0.6);
      border-radius: 15px;
      padding: 30px;
      width: 100%;
      max-width: 800px;
      box-shadow: 0 0 20px rgba(100, 100, 255, 0.3),
                  0 0 60px rgba(100, 100, 255, 0.1);
      backdrop-filter: blur(5px);
      animation: glow 4s infinite alternate;
      margin: auto 0;
    }
    
    @keyframes glow {
      0% {
        box-shadow: 0 0 20px rgba(100, 100, 255, 0.3),
                    0 0 60px rgba(100, 100, 255, 0.1);
      }
      100% {
        box-shadow: 0 0 25px rgba(100, 100, 255, 0.4),
                    0 0 70px rgba(100, 100, 255, 0.2);
      }
    }
    
    h1 {
      font-size: 3rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    
    p {
      font-size: 1.2rem;
      max-width: 600px;
      margin: 0 auto 2rem;
    }
    
    .button-container {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      justify-content: center;
    }
    
    .cosmic-button {
      padding: 12px 24px;
      font-size: 1rem;
      background-color: rgba(255, 255, 255, 0.1);
      border: 2px solid #fff;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      border-radius: 30px;
    }
    
    .cosmic-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }
    
    #fileInfo {
      margin-top: 20px;
      font-style: italic;
    }
    
    /* Notification and Download Button Styles */
    #notification {
      display: none;
      margin-top: 20px;
      padding: 15px;
      background-color: #28a745;
      color: white;
      border-radius: 5px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }

    #downloadButton {
      display: none;
      padding: 10px 20px;
      font-size: 1rem;
      background-color: rgba(255, 255, 255, 0.1);
      border: 2px solid #fff;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      border-radius: 30px;
      margin-top: 10px;
      display: inline-block;
    }

    #downloadButton:hover {
      background-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }

    /* Loader Styles */
    .loader {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 2s linear infinite;
      margin: 20px auto;
      display: none;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #processButton:disabled {
      background-color: rgba(255, 255, 255, 0.2);
      cursor: not-allowed;
      box-shadow: none;
    }

    /* Combined Twinkle and Float Animation */
    @keyframes twinkle-float {
      0% {
        opacity: 0;
        transform: translateY(0px) scale(0.5);
      }
      50% {
        opacity: 1;
        transform: translateY(-20px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(0px) scale(0.5);
      }
    }
    
    @keyframes shoot {
      0% { transform: rotate(var(--shoot-rotate, 0rad)) translate(0, 0); opacity: 1; }
      100% { transform: rotate(var(--shoot-rotate, 0rad)) translate(300px, 300px); opacity: 0; }
    }
    
    .star {
      position: absolute;
      background-color: #fff;
      border-radius: 50%;
      pointer-events: none;
      /* Apply the combined animation */
      animation-name: twinkle-float;
      animation-timing-function: ease-in-out;
      animation-iteration-count: infinite;
      animation-direction: alternate;
      /* The duration and delay will be set via inline styles in JS */
    }
    
    .shooting-star {
      position: absolute;
      width: 2px;
      height: 2px;
      background-color: #fff;
      pointer-events: none;
      /* The animation will be set via inline styles in JS */
    }
    
    .logo {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
    }
    
    .logo img {
      width: 120px; /* Increased from 100px to 120px */
      height: auto;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
      transition: transform 0.3s ease;
    }
    
    .logo img:hover {
      transform: scale(1.1);
    }
    
    footer {
      width: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      color: #fff;
      text-align: center;
      padding: 10px 0;
      font-size: 0.8rem;
    }
    
    footer a {
      color: #fff;
      text-decoration: none;
    }
    
    footer a:hover {
      text-decoration: underline;
    }
    
    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.8);
    }
    
    .modal-content {
      background-color: rgba(25, 25, 35, 0.9);
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 600px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(100, 100, 255, 0.3);
    }
    
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close:hover,
    .close:focus {
      color: #fff;
      text-decoration: none;
    }
  </style>
</head>
<body>

  <div class="stars" id="stars"></div>

  <div class="content">
    <div class="logo">
      <img src="https://clearufo.space/logo.png" alt="Cosmic Enigma Logo" width="120" height="120" id="logoImage">
    </div>

    <div class="glowing-window">
      <h1>Cosmic Enigma</h1>
      <p>Upload your cosmic data for analysis and processing</p>
      
      <div class="button-container">
        <label for="fileInput" class="cosmic-button">Upload File</label>
        <input type="file" id="fileInput" style="display: none;" accept="image/*,video/*">
        <button id="processButton" class="cosmic-button">Process File</button>
      </div>
      
      <div id="fileInfo"></div>
      <div class="loader" id="loader"></div>
      <div id="notification">
        <p id="notificationText"></p>
        <a href="#" id="downloadButton" download>Download Processed File</a>
      </div>
    </div>

    <footer>
      <p>Â© 2023 Cosmic Enigma. All rights reserved. | <a href="https://websim.ai/privacy">Privacy Policy</a> | <a href="https://websim.ai/terms">Terms of Service</a></p>
    </footer>
  </div>

  <!-- Modal -->
  <div id="logoModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>About Cosmic Enigma</h2>
      <p>Cosmic Enigma is at the forefront of unraveling the mysteries of the universe. Our advanced data processing algorithms help researchers, astronomers, and space enthusiasts analyze cosmic phenomena and unlock the secrets of the cosmos.</p>
      <p>Founded in 2023, we've been pushing the boundaries of space exploration and data analysis. Our mission is to make the vast expanse of space more accessible and understandable to everyone.</p>
      <p>Join us on this incredible journey as we explore the unknown and shed light on the cosmic enigmas that surround us.</p>
    </div>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <!-- FFmpeg.wasm -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

  <script>
    // Star Animation Code
    class Star {
      constructor(container) {
        this.element = document.createElement('div');
        this.element.className = 'star';
        this.reset();
        container.appendChild(this.element);
      }
    
      reset() {
        const size = Math.random() * 3 + 1;
        this.element.style.width = `${size}px`;
        this.element.style.height = `${size}px`;
        this.element.style.left = `${Math.random() * 100}%`;
        this.element.style.top = `${Math.random() * 100}%`;
        
        const duration = Math.random() * 2 + 2; // Adjusted duration for smoother animation
        const delay = Math.random() * 4; // Increased delay range to spread out twinkles
        this.element.style.animationDuration = `${duration}s`;
        this.element.style.animationDelay = `${delay}s`;
      }
    }
    
    class ShootingStar {
      constructor(container) {
        this.element = document.createElement('div');
        this.element.className = 'shooting-star';
        this.reset();
        container.appendChild(this.element);
      }
    
      reset() {
        const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Limiting angle for more natural shooting stars
        const size = Math.random() * 2 + 1;
        
        this.element.style.width = `${size}px`;
        this.element.style.height = `${size}px`;
        this.element.style.left = `${Math.random() * 100}%`;
        this.element.style.top = `${Math.random() * 100}%`;
        
        const duration = Math.random() * 1.5 + 1.5;
        this.element.style.setProperty('--shoot-rotate', angle);
        this.element.style.animation = `shoot ${duration}s linear forwards`;
        
        // Remove any existing animationend listeners to prevent multiple triggers
        this.element.removeEventListener('animationend', this.resetBound);
        this.resetBound = this.reset.bind(this);
        this.element.addEventListener('animationend', this.resetBound);
      }
    }
    
    function createStarfield() {
      const container = document.getElementById('stars');
      const starCount = Math.floor((window.innerWidth * window.innerHeight) / 1000);
      
      for (let i = 0; i < starCount; i++) {
        new Star(container);
      }
      
      for (let i = 0; i < 5; i++) { // Number of shooting stars can be adjusted
        new ShootingStar(container);
      }
    }
    
    createStarfield();
    
    window.addEventListener('resize', () => {
      const container = document.getElementById('stars');
      container.innerHTML = '';
      createStarfield();
    });
    
    // Modal Functionality
    const modal = document.getElementById('logoModal');
    const logoImage = document.getElementById('logoImage');
    const closeButton = document.getElementsByClassName('close')[0];
    
    logoImage.onclick = function() {
      modal.style.display = 'block';
    }
    
    closeButton.onclick = function() {
      modal.style.display = 'none';
    }
    
    window.onclick = function(event) {
      if (event.target == modal) {
        modal.style.display = 'none';
      }
    }

    // Processing Logic
    const fileInput = document.getElementById('fileInput');
    const processButton = document.getElementById('processButton');
    const fileInfo = document.getElementById('fileInfo');
    const loader = document.getElementById('loader');
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notificationText');
    const downloadButton = document.getElementById('downloadButton');

    let processedBlob = null;

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        fileInfo.textContent = `Selected file: ${file.name}`;
        processButton.style.display = 'inline-block';
        notification.style.display = 'none';
        downloadButton.style.display = 'none';
      } else {
        fileInfo.textContent = '';
        processButton.style.display = 'none';
      }
    });

    processButton.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) return;

      fileInfo.textContent = `Processing ${file.name}...`;
      processButton.disabled = true;
      loader.style.display = 'block';
      notification.style.display = 'none';
      downloadButton.style.display = 'none';

      try {
        if (file.type.startsWith('image/')) {
          processedBlob = await processImage(file);
        } else if (file.type.startsWith('video/')) {
          processedBlob = await processVideo(file);
        } else {
          throw new Error('Unsupported file type');
        }

        const url = URL.createObjectURL(processedBlob);
        downloadButton.href = url;
        downloadButton.download = `processed_${file.name}`;
        downloadButton.style.display = 'inline-block';

        notificationText.textContent = `${file.name} has been processed successfully!`;
        notification.style.display = 'block';
      } catch (error) {
        console.error(error);
        fileInfo.textContent = `Error: ${error.message}`;
      } finally {
        processButton.disabled = false;
        loader.style.display = 'none';
      }
    });

    // Function to Process Images Using OpenCV.js
    async function processImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async function(e) {
          const img = new Image();
          img.onload = function() {
            try {
              // Create a canvas to draw the image
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);

              // Load image data into OpenCV
              let src = cv.imread(canvas);
              
              // Convert to HSV
              let hsv = new cv.Mat();
              cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
              cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

              // Split channels
              let channels = new cv.MatVector();
              cv.split(hsv, channels);
              let h = channels.get(0);
              let s = channels.get(1);
              let v = channels.get(2);

              // Save H channel as grayscale image
              // For demonstration, we'll merge H with zero S and V to visualize
              let zeroMat = cv.Mat.zeros(h.rows, h.cols, h.type());
              let hImage = new cv.MatVector();
              hImage.push_back(h);
              hImage.push_back(zeroMat);
              hImage.push_back(zeroMat);
              let hMerged = new cv.Mat();
              cv.merge(hImage, hMerged);
              cv.cvtColor(hMerged, hMerged, cv.COLOR_HSV2RGB); // Convert back to RGB for visualization
              cv.imshow(canvas, hMerged);

              // Convert canvas to Blob (H channel image)
              canvas.toBlob(async (hBlob) => {
                // Proceed to apply Histogram Equalization to V channel
                // Equalize V channel
                cv.equalizeHist(v, v);

                // Merge channels back
                let channelsEq = new cv.MatVector();
                channelsEq.push_back(h);
                channelsEq.push_back(s);
                channelsEq.push_back(v);
                cv.merge(channelsEq, hsv);
                cv.cvtColor(hsv, hsv, cv.COLOR_HSV2RGB);
                cv.cvtColor(hsv, hsv, cv.COLOR_RGB2RGBA);
                cv.imshow(canvas, hsv); // Display the final image

                // Convert the final canvas to Blob
                canvas.toBlob((finalBlob) => {
                  // Clean up
                  h.delete();
                  s.delete();
                  v.delete();
                  zeroMat.delete();
                  hImage.delete();
                  hMerged.delete();
                  channelsEq.delete();
                  hsv.delete();
                  src.delete();

                  resolve(finalBlob);
                }, 'image/png');
              }, 'image/png');

            } catch (err) {
              reject(err);
            }
          };
          img.onerror = function() {
            reject(new Error('Failed to load image'));
          };
          img.src = e.target.result;
        };
        reader.onerror = function() {
          reject(new Error('Failed to read file'));
        };
        reader.readAsDataURL(file);
      });
    }

    // Function to Process Videos Using FFmpeg.wasm
    async function processVideo(file) {
      const { createFFmpeg, fetchFile } = FFmpeg;
      const ffmpeg = createFFmpeg({ log: true });
      await ffmpeg.load();

      // Step 1: Write the input file to FFmpeg's virtual filesystem
      ffmpeg.FS('writeFile', 'input', await fetchFile(file));

      // Step 2: Extract HSV channels
      // FFmpeg doesn't provide direct HSV extraction, so we use colorchannelmixer and other filters to manipulate channels
      // However, to specifically extract the H channel, we need to use a workaround.

      // To extract H channel as a separate video
      const extractHFilter = 'hue=s=0'; // This effectively removes saturation, highlighting the H channel

      // To apply Histogram Equalization to V channel, we'll use the eq filter on the V channel via LUTs or available filters
      // FFmpeg's eq filter works on RGB, so histogram equalization on V channel isn't straightforward
      // As a workaround, we'll apply histogram equalization to the whole brightness

      // To apply Temporal Smoothing (e.g., box blur over 5 frames)
      // We'll use the minterpolate filter to increase FPS and then apply boxblur

      // Combining all filters
      const filter = `
        hue=s=0,
        eq=brightness=0:contrast=1:gamma=1,
        boxblur=5:5
      `;

      // Clean filter string
      const cleanedFilter = filter.replace(/\s+/g, '');

      try {
        // Apply filters and generate processed video
        await ffmpeg.run(
          '-i', 'input',
          '-vf', cleanedFilter,
          '-c:a', 'copy',
          'output.mp4'
        );
      } catch (error) {
        throw new Error('FFmpeg processing failed: ' + error.message);
      }

      // Read the output file
      const data = ffmpeg.FS('readFile', 'output.mp4');

      // Cleanup
      ffmpeg.FS('unlink', 'input');
      ffmpeg.FS('unlink', 'output.mp4');

      // Return the processed video as a Blob
      return new Blob([data.buffer], { type: 'video/mp4' });
    }

    // Handle OpenCV.js Ready State
    // Wait until OpenCV is loaded
    function onOpenCvReady() {
      if (cv && cv.getBuildInformation) {
        console.log(cv.getBuildInformation());
      } else {
        setTimeout(onOpenCvReady, 100);
      }
    }
    onOpenCvReady();
  </script>
  
</body>
</html>
