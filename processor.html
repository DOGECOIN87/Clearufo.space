<!DOCTYPE html>
<html>
<head>
  <base href="https://websim.ai/cosmic-enigma/">
  <title>CLEARUFO.SPACE IMAGE/VIDEO PROCESSOR - Full Page Layout</title>
  <style>
    /* [Your existing CSS styles here...] */
    /* ... (omitted for brevity, use the provided CSS from your original HTML) ... */
    /* Add styles for the download button and notification */
    #notification {
      display: none;
      margin-top: 20px;
      padding: 15px;
      background-color: #28a745;
      color: white;
      border-radius: 5px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }

    #downloadButton {
      display: none;
      padding: 10px 20px;
      font-size: 1rem;
      background-color: rgba(255, 255, 255, 0.1);
      border: 2px solid #fff;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      border-radius: 30px;
      margin-top: 10px;
      display: inline-block;
    }

    #downloadButton:hover {
      background-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }

    /* Loader Styles */
    .loader {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 2s linear infinite;
      margin: 20px auto;
      display: none;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #processButton:disabled {
      background-color: rgba(255, 255, 255, 0.2);
      cursor: not-allowed;
      box-shadow: none;
    }

    /* Combined Twinkle and Float Animation */
    @keyframes twinkle-float {
      0% {
        opacity: 0;
        transform: translateY(0px) scale(0.5);
      }
      50% {
        opacity: 1;
        transform: translateY(-20px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(0px) scale(0.5);
      }
    }
    
    @keyframes shoot {
      0% { transform: rotate(var(--shoot-rotate, 0rad)) translate(0, 0); opacity: 1; }
      100% { transform: rotate(var(--shoot-rotate, 0rad)) translate(300px, 300px); opacity: 0; }
    }
    
    .star {
      position: absolute;
      background-color: #fff;
      border-radius: 50%;
      pointer-events: none;
      /* Apply the combined animation */
      animation-name: twinkle-float;
      animation-timing-function: ease-in-out;
      animation-iteration-count: infinite;
      animation-direction: alternate;
      /* The duration and delay will be set via inline styles in JS */
    }
    
    .shooting-star {
      position: absolute;
      width: 2px;
      height: 2px;
      background-color: #fff;
      pointer-events: none;
      /* The animation will be set via inline styles in JS */
    }
    
    .logo {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
    }
    
    .logo img {
      width: 120px; /* Increased from 100px to 120px */
      height: auto;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
      transition: transform 0.3s ease;
    }
    
    .logo img:hover {
      transform: scale(1.1);
    }
    
    footer {
      width: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      color: #fff;
      text-align: center;
      padding: 10px 0;
      font-size: 0.8rem;
    }
    
    footer a {
      color: #fff;
      text-decoration: none;
    }
    
    footer a:hover {
      text-decoration: underline;
    }
    
    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.8);
    }
    
    .modal-content {
      background-color: rgba(25, 25, 35, 0.9);
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 600px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(100, 100, 255, 0.3);
    }
    
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close:hover,
    .close:focus {
      color: #fff;
      text-decoration: none;
    }
  </style>
</head>
<body>

  <div class="stars" id="stars"></div>

  <div class="content">
    <div class="logo">
      <img src="https://clearufo.space/logo.png" alt="Cosmic Enigma Logo" width="120" height="120" id="logoImage">
    </div>

    <div class="glowing-window">
      <h1>Cosmic Enigma</h1>
      <p>Upload your cosmic data for analysis and processing</p>
      
      <div class="button-container">
        <label for="fileInput" class="cosmic-button">Upload File</label>
        <input type="file" id="fileInput" style="display: none;" accept="image/*,video/*">
        <button id="processButton" class="cosmic-button">Process File</button>
      </div>
      
      <div id="fileInfo"></div>
      <div class="loader" id="loader"></div>
      <div id="notification">
        <p id="notificationText"></p>
        <a href="#" id="downloadButton" download>Download Processed File</a>
      </div>
    </div>

    <footer>
      <p>Â© 2023 Cosmic Enigma. All rights reserved. | <a href="https://websim.ai/privacy">Privacy Policy</a> | <a href="https://websim.ai/terms">Terms of Service</a></p>
    </footer>
  </div>

  <!-- Modal -->
  <div id="logoModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>About Cosmic Enigma</h2>
      <p>Cosmic Enigma is at the forefront of unraveling the mysteries of the universe. Our advanced data processing algorithms help researchers, astronomers, and space enthusiasts analyze cosmic phenomena and unlock the secrets of the cosmos.</p>
      <p>Founded in 2023, we've been pushing the boundaries of space exploration and data analysis. Our mission is to make the vast expanse of space more accessible and understandable to everyone.</p>
      <p>Join us on this incredible journey as we explore the unknown and shed light on the cosmic enigmas that surround us.</p>
    </div>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <!-- FFmpeg.wasm -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>

  <script>
    // Star Animation Code
    class Star {
      constructor(container) {
        this.element = document.createElement('div');
        this.element.className = 'star';
        this.reset();
        container.appendChild(this.element);
      }
    
      reset() {
        const size = Math.random() * 3 + 1;
        this.element.style.width = `${size}px`;
        this.element.style.height = `${size}px`;
        this.element.style.left = `${Math.random() * 100}%`;
        this.element.style.top = `${Math.random() * 100}%`;
        
        const duration = Math.random() * 2 + 2; // Adjusted duration for smoother animation
        const delay = Math.random() * 4; // Increased delay range to spread out twinkles
        this.element.style.animationDuration = `${duration}s`;
        this.element.style.animationDelay = `${delay}s`;
      }
    }
    
    class ShootingStar {
      constructor(container) {
        this.element = document.createElement('div');
        this.element.className = 'shooting-star';
        this.reset();
        container.appendChild(this.element);
      }
    
      reset() {
        const angle = Math.random() * Math.PI / 4 - Math.PI / 8; // Limiting angle for more natural shooting stars
        const size = Math.random() * 2 + 1;
        
        this.element.style.width = `${size}px`;
        this.element.style.height = `${size}px`;
        this.element.style.left = `${Math.random() * 100}%`;
        this.element.style.top = `${Math.random() * 100}%`;
        
        const duration = Math.random() * 1.5 + 1.5;
        this.element.style.setProperty('--shoot-rotate', angle);
        this.element.style.animation = `shoot ${duration}s linear forwards`;
        
        // Remove any existing animationend listeners to prevent multiple triggers
        this.element.removeEventListener('animationend', this.resetBound);
        this.resetBound = this.reset.bind(this);
        this.element.addEventListener('animationend', this.resetBound);
      }
    }
    
    function createStarfield() {
      const container = document.getElementById('stars');
      const starCount = Math.floor((window.innerWidth * window.innerHeight) / 1000);
      
      for (let i = 0; i < starCount; i++) {
        new Star(container);
      }
      
      for (let i = 0; i < 5; i++) { // Number of shooting stars can be adjusted
        new ShootingStar(container);
      }
    }
    
    createStarfield();
    
    window.addEventListener('resize', () => {
      const container = document.getElementById('stars');
      container.innerHTML = '';
      createStarfield();
    });
    
    // Modal Functionality
    const modal = document.getElementById('logoModal');
    const logoImage = document.getElementById('logoImage');
    const closeButton = document.getElementsByClassName('close')[0];
    
    logoImage.onclick = function() {
      modal.style.display = 'block';
    }
    
    closeButton.onclick = function() {
      modal.style.display = 'none';
    }
    
    window.onclick = function(event) {
      if (event.target == modal) {
        modal.style.display = 'none';
      }
    }

    // Processing Logic
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({ log: true }); // Enable logging for debugging
    let isFFmpegLoaded = false;
    
    const fileInput = document.getElementById('fileInput');
    const processButton = document.getElementById('processButton');
    const fileInfo = document.getElementById('fileInfo');
    const loader = document.getElementById('loader');
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notificationText');
    const downloadButton = document.getElementById('downloadButton');
    
    let processedBlob = null;
    
    // Initialize FFmpeg
    async function initFFmpeg() {
      if (!isFFmpegLoaded) {
        await ffmpeg.load();
        isFFmpegLoaded = true;
        console.log('FFmpeg loaded successfully');
      }
    }
    
    // Function to Process Images Using OpenCV.js
    async function processImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async function(e) {
          const img = new Image();
          img.onload = function() {
            try {
              // Create a canvas to draw the image
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
  
              // Load image data into OpenCV
              let src = cv.imread(canvas);
              
              // Convert to HSV
              let hsv = new cv.Mat();
              cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
              cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
  
              // Split channels
              let channels = new cv.MatVector();
              cv.split(hsv, channels);
              let h = channels.get(0); // Hue channel
  
              // Normalize H channel to 0-255 for grayscale representation
              let hNormalized = new cv.Mat();
              cv.normalize(h, hNormalized, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1);
  
              // Apply Histogram Equalization to the normalized H channel
              let hEqualized = new cv.Mat();
              cv.equalizeHist(hNormalized, hEqualized);
  
              // Convert to grayscale image
              cv.imshow(canvas, hEqualized);
  
              // Convert the final canvas to Blob
              canvas.toBlob((finalBlob) => {
                // Clean up
                h.delete();
                hNormalized.delete();
                hEqualized.delete();
                channels.delete();
                hsv.delete();
                src.delete();
  
                resolve(finalBlob);
              }, 'image/png');
  
            } catch (err) {
              reject(err);
            }
          };
          img.onerror = function() {
            reject(new Error('Failed to load image'));
          };
          img.src = e.target.result;
        };
        reader.onerror = function() {
          reject(new Error('Failed to read file'));
        };
        reader.readAsDataURL(file);
      });
    }
    
    // Function to Process Videos Using FFmpeg.wasm
    async function processVideo(file) {
      return new Promise(async (resolve, reject) => {
        try {
          // Write the input file to FFmpeg's virtual filesystem
          ffmpeg.FS('writeFile', 'input', await fetchFile(file));
  
          // Define the processing command
          // Step 1: Extract H channel as grayscale
          // Step 2: Apply Histogram Equalization
          // Step 3: Apply Temporal Smoothing over 5 frames
  
          // FFmpeg filter complex for Image Processing:
          // Convert to HSV, extract H channel, normalize, equalize, convert back to grayscale
          const filterImage = `
            [0:v] split=2 [h][orig];
            [h] hue=s=0, colorchannelmixer=0.0:0.0:1.0:0.0:0.0:0.0:0.0:0.0:0.0, format=gray, histeq [h_eq]
          `;
  
          // Step 1: Extract and process H channel
          await ffmpeg.run(
            '-i', 'input',
            '-filter_complex', filterImage,
            '-map', '[h_eq]',
            '-c:v', 'png',
            'h_eq.png'
          );
  
          // Read the processed image
          const hEqData = ffmpeg.FS('readFile', 'h_eq.png');
          const hEqBlob = new Blob([hEqData.buffer], { type: 'image/png' });
  
          // Step 2: Extract V channel, apply Histogram Equalization
          // Extract V channel
          const filterV = `
            [0:v] split=2 [v][orig];
            [v] hue=s=0, colorchannelmixer=0.0:0.0:1.0:0.0:0.0:0.0:0.0:0.0:0.0, format=gray, histeq [v_eq]
          `;
  
          await ffmpeg.run(
            '-i', 'input',
            '-filter_complex', filterV,
            '-map', '[v_eq]',
            '-c:v', 'png',
            'v_eq.png'
          );
  
          // Read the processed V channel
          const vEqData = ffmpeg.FS('readFile', 'v_eq.png');
          const vEqBlob = new Blob([vEqData.buffer], { type: 'image/png' });
  
          // Note: For accurate H and V manipulation, deeper processing would be required.
          // FFmpeg's capabilities are limited for per-channel histogram equalization without affecting others.
  
          // Step 3: Temporal Smoothing (for videos)
          // Apply Temporal Smoothing over 5 frames using minterpolate with fps=desired
          // Alternatively, use tblend to average over frames
  
          // For simplicity, using tblend with average over 5 frames
          const filterVideo = `
            [0:v] tblend=average, framestep=5 [out]
          `;
  
          await ffmpeg.run(
            '-i', 'input',
            '-filter_complex', filterVideo,
            '-c:v', 'libx264',
            '-crf', '18',
            '-preset', 'veryfast',
            'output.mp4'
          );
  
          // Read the processed video
          const outputData = ffmpeg.FS('readFile', 'output.mp4');
          const outputBlob = new Blob([outputData.buffer], { type: 'video/mp4' });
  
          // Cleanup
          ffmpeg.FS('unlink', 'input');
          ffmpeg.FS('unlink', 'h_eq.png');
          ffmpeg.FS('unlink', 'v_eq.png');
          ffmpeg.FS('unlink', 'output.mp4');
  
          resolve(outputBlob);
  
        } catch (error) {
          reject(error);
        }
      });
    }
    
    // Handle File Selection
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        fileInfo.textContent = `Selected file: ${file.name}`;
        processButton.style.display = 'inline-block';
        notification.style.display = 'none';
        downloadButton.style.display = 'none';
      } else {
        fileInfo.textContent = '';
        processButton.style.display = 'none';
      }
    });
    
    // Handle Process Button Click
    processButton.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) return;
  
      fileInfo.textContent = `Processing ${file.name}...`;
      processButton.disabled = true;
      loader.style.display = 'block';
      notification.style.display = 'none';
      downloadButton.style.display = 'none';
  
      try {
        await initFFmpeg();
  
        if (file.type.startsWith('image/')) {
          // Process Image
          processedBlob = await processImage(file);
  
        } else if (file.type.startsWith('video/')) {
          // Process Video
          processedBlob = await processVideo(file);
  
        } else {
          throw new Error('Unsupported file type');
        }
  
        const url = URL.createObjectURL(processedBlob);
        downloadButton.href = url;
        downloadButton.download = `processed_${file.name}`;
        downloadButton.style.display = 'inline-block';
  
        notificationText.textContent = `${file.name} has been processed successfully!`;
        notification.style.display = 'block';
  
      } catch (error) {
        console.error(error);
        fileInfo.textContent = `Error: ${error.message}`;
        alert(`Processing failed: ${error.message}`);
      } finally {
        processButton.disabled = false;
        loader.style.display = 'none';
      }
    });
  
  </script>
  
</body>
</html>
